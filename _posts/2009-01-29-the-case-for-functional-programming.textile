---
layout: post
title:        The Case For Functional Programming
date-updated: 30 Jan 2009
---

h2. Comparing Different Language Levels

For illustration purposes, we'll use the recipe I chose by asking Google's first result for @recipe@, and clicking on two links. The first one led me to a deserts page, and the second one to the yummy-looking "Blueberry Buckle":http://allrecipes.com/Recipe/Blueberry-Buckle/Detail.aspx.

As you will see below, I have inlined the ingredients' measures directly in their preparation directions.

h3. Expressed In Natural Language

# Preheat oven to 375 degrees. Grease one 8x8 inch pan.
# Cream together 3/4 cup sugar, 1/4 cup shortening, and one egg.
# In a separate bowl mix together 2 cups flour, 2 teaspoons baking powder, and 1/2 teaspoon salt. Stir into sugar mixture, alternating with 1/2 cup milk. Stir in 2 cups fresh blueberries. Pour into greased 8x8 inch pan.
# To make topping: Combine 1/2 cup sugar, 1/3 cup flour, 1/2 teaspoon ground cinnamon, and 1/4 cup butter. Sprinkle over cake batter.
# Bake at 375 degree for 25-30 minutes.

h3. Expressed In An Imperative Language

Here's the same recipe, this time expressed in some dialect of Java:

{% highlight java %}
Chef   chef       = new Chef();

Oven   oven       = new Oven();
Pan    pan        = new Pan(8, 8);
Grease shortening = new Crisco();

chef.prepare(oven, 375);
chef.prepare(pan,  shortening);

Mixture cream = chef.mix(
 chef.prepare(new Sugar(),          Units.cup(3/4)),
 chef.prepare(shortening,           Units.cup(1/4)),
 chef.prepare(new Egg()));

Mixture cake = chef.mix(
 chef.prepare(new Flour(),          Units.cup(2)),
 chef.prepare(new BakingPowder(),   Units.teaspoon(2)),
 chef.prepare(new Salt(),           Units.teaspoon(1/2)));

cake = chef.mixProgressively(
 cake,
 cream,
 chef.prepare(new Milk(),           Units.cup(1/2)));

cake = chef.stir(
 cake,
 chef.prepare(new Blueberries(),    Units.cup(2)));

chef.pour(cake, pan);

Mixture topping = chef.mix(
 chef.prepare(new Sugar(),          Units.cup(1/2)),
 chef.prepare(new Flour(),          Units.cup(1/3)),
 chef.prepare(new GroundCinnamon(), Units.teaspoon(1/2)),
 chef.prepare(new Butter(),         Units.cup(1/4)));

chef.sprinkle(topping, pan);

chef.waitFor(oven);

return chef.bake(pan, oven, 25, 30);
{% endhighlight %}

h3. Expressed In An Equational Language

{% highlight haskell %}
blueberryBuckle = Oven 375 readyCake [25..30]

readyCake       = sprinkle topping panCake
  where topping = mix [(Sugar          (Cup 1/2)),
                       (Flour          (Cup 1/3)),
                       (GroundCinnamon (Teaspoon 1/2)),
                       (Butter         (Cup 1/4))]

panCake         = pour blueCake (Pan [8,8] Crisco)

blueCake        = stir (BlueBerries (Cup 2)) smoothCake

smoothCake      = mixProgressively [milk,cream,base]
  where milk    = (Milk (Cup 1/2))
        cream   = mix [(Sugar  (Cup 3/4)),
                       (Crisco (Cup 1/4)),
                       Egg]
        base    = mix [(Flour        (Cup 2)),
                       (BakingPowder (Teaspoon 2)),
                       (Salt         (Teaspoon 1/2))]
{% endhighlight %}


h3. Stop taking the Chef for a fool!

h3. Who's The Chef?

h2. Is Formality What We Want?

Then express it through a formal language!

h2. Value Transparency, not Opaqueness


h2. Fundamental Problems Of The Imperative Way

h3. The Assignment Statement

Turner, p.5, "It is because of this that it is so difficult to reason about programs. Since expressions can change their value through time, equality is not substitutive. Indeed, in a programming language it does not even have to be true that an expression is equal to itself (because the presence of side effects may mean that evaluating the same expression twice in succession can produce two different answers)! In general it is not possible to reason about such programs on the basis of a static analysis of the program text - instead we have to think of the program dynamically and follow the detailed flow of control [...]"

h2. The Imperative Coalition's Last Hopes

h3. Object Orientation

h3. Higher-Order Functions

h3. Limits

h2. References

h3. 1977 - John Backus

h4. Bio

*** "Wikipedia's Page":en.wikipedia.org/wiki/John_Backus
*** "Alex Aiken's Memorial":theory.stanford.edu/~aiken/other/backus.pdf
*** "IBM's Exhibit":http://www-03.ibm.com/ibm/history/exhibits/builders/builders_backus.html

h4. Paper

*** "Can Programming Be Liberated from the von Neumann Style?":theory.stanford.edu/~aiken/other/backus.pdf

h3. 1982 - David Turner

h3. 1984 - John Hughes

** "Why Functional Programming Matters":www.address.com
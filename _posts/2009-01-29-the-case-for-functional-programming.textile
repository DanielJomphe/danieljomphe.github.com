---
layout: post
title:        The Case For Functional Programming
date-updated: 31 Jan 2009
---

_Please consider the following as draft-quality stuff._<br />
_I'm in the process of writing it and ramping up its average quality by a serious notch or two._

h2. Comparing Different Language Levels

In this section, we will derive important conclusions from real life observations.

h3. How To Reach Truthful Conclusions

To this avail, we need to pick someone very special.

h4. Qualifications Of Yours Truly

Well, ehr, we _can't_ use me. Why? Because I'm a Java and C++ programmer. Because I'm no expert. Because I'm not used to any other kind of programming than what is called Imperative Programming. You know, although I certainly ain't nobody, I'm still not too far from being your regular Joe.

Now, thinking of this, I know _someone_ who's not your average Joe at all. Yes, that's right: we'll pick him! This guy's uniquely qualified to derive objective conclusions. Ladies and Gentlemen, allow me to present you _the_ John Smith.

h4. Qualifications Of John Smith

Why John Smith? Because, you see, John Smith is the only guy in the world who's a complete expert of all the programming language dialects I'm going to use in this article. All of them, no trick!

More importantly and more impressively, _John Smith learned those languages perfectly concurrently_, and _used them equally ever since_. And yet, as if this was not enough qualifications for him, John has been spending 1 hour per working day since the start of his career in 1996, speaking about these different languages with his dozens of siblings who go by the same name as his', but work in very different contexts. And guess what? _They all share this very same background._ They all think along the same lines as John's. Can you believe it? Incredible, isn't it?

Now, consequently, allow me to truthfully claim that John Smith is, _out of any possible doubt_, the very best person to help us reach meaningful conclusions about the fundamental differences of these languages.

Doesn't it feel great to have John Smith with us to help us think this all through? Thanks John, I owe you one!

h3. Natural Language - The Testbed

Now that we have introduced John Smith, let's talk about the program we will use to compare our different languages.

John said any program could do, so for illustration purposes, this program will be a recipe I chose by asking Google's first result for @recipe@, and clicking on two links. The first one led me to a deserts page, and the second one to the yummy-looking "Blueberry Buckle":http://allrecipes.com/Recipe/Blueberry-Buckle/Detail.aspx. This recipe's directions are what we will program.

h4. Some English Dialect

For the sake of simplicity, I have inserted the ingredients and their measures right into their preparation directions:

# Preheat oven to 375 degrees. Grease one 8x8 inch pan.
# Cream together 3/4 cup sugar, 1/4 cup shortening, and one egg.
# In a separate bowl mix together 2 cups flour, 2 teaspoons baking powder, and 1/2 teaspoon salt. Stir into sugar mixture, alternating with 1/2 cup milk. Stir in 2 cups fresh blueberries. Pour into greased 8x8 inch pan.
# To make topping: Combine 1/2 cup sugar, 1/3 cup flour, 1/2 teaspoon ground cinnamon, and 1/4 cup butter. Sprinkle over cake batter.
# Bake at 375 degree for 25-30 minutes.

Now, let's see how this may be programmed. Please note that in the following versions of these directions, I have, out of pure laziness, left some functions undefined.

h3. Functional Language

h4. Some Haskell Dialect

Remark how this code feels like mathematical equations:

{% highlight haskell %}
blueberryBuckle = bake Oven 375 readyCake [25..30]

readyCake       = sprinkle topping panCake
  where topping = mix [(Sugar        (Cup 1/2)),
                       (Flour        (Cup 1/3)),
                       (Cinnamon     (Teaspoon 1/2)),
                       (Butter       (Cup 1/4))]

panCake         = pour blueCake (Pan [8,8] Crisco)

blueCake        = stir (BlueBerries  (Cup 2)) smoothCake

smoothCake      = mixProgressively [(Milk (Cup 1/2)),cream,base]
  where cream   = mix [(Sugar        (Cup 3/4)),
                       (Crisco       (Cup 1/4)),
                       Egg]
        base    = mix [(Flour        (Cup 2)),
                       (BakingPowder (Teaspoon 2)),
                       (Salt         (Teaspoon 1/2))]
{% endhighlight %}

According to John Smith, this version of the program is _the_ *fastest* and *easiest* to read, write, and maintain.

(He already took a look at the other versions that follow. What a dude!)

Hey, _doesn't this mean that the Java version isn't the fastest and easiest one_?

Doesn't this feel weird to you? John may say this, but what's the heck anyway with these weird functional, academic-level languages, right? Such languages aren't fit for critical production usage. They would crumble under hardship. They're not battle-tested. They're not widely used. They're too hard to learn. Right?

Wait, John says these assumptions of ours are all false. How could it be? Let's skip to the next section, may we?

h3. Imperative Language

h4. Some Object-Oriented Java Dialect

Ah, _home, sweet home_. How reassuring is the smell of _home, sweet home_, isn't it?

{% highlight java %}
public class Chef {
  public static BlueberryBuckle main(String args[]) {
    Chef   chef       = new Chef();

    Oven   oven       = new Oven();
    Pan    pan        = new Pan(8, 8);
    Grease shortening = new Crisco();

    chef.prepare(oven, 375);
    chef.prepare(pan,  shortening);

    Mixture cream = chef.mix(
      chef.prepare(new Sugar(),        Units.cup(3/4)),
      chef.prepare(shortening,         Units.cup(1/4)),
      chef.prepare(new Egg()));

    Mixture cake = chef.mix(
      chef.prepare(new Flour(),        Units.cup(2)),
      chef.prepare(new BakingPowder(), Units.teaspoon(2)),
      chef.prepare(new Salt(),         Units.teaspoon(1/2)));

    cake = chef.mixProgressively(
      cake,
      cream,
      chef.prepare(new Milk(),         Units.cup(1/2)));

    cake = chef.stir(
      cake,
      chef.prepare(new Blueberries(),  Units.cup(2)));

    chef.pour(cake, pan);

    Mixture topping = chef.mix(
      chef.prepare(new Sugar(),        Units.cup(1/2)),
      chef.prepare(new Flour(),        Units.cup(1/3)),
      chef.prepare(new Cinnamon(),     Units.teaspoon(1/2)),
      chef.prepare(new Butter(),       Units.cup(1/4)));

    chef.sprinkle(topping, pan);

    chef.waitFor(oven);

    return chef.bake(pan, oven, 25, 30);
  }
}
{% endhighlight %}

Now, try to imagine how you would program the unimplemented methods, like chef.mixProgressively(...). Try a little more. Form yourself a mental picture. Continue, it's not clear enough. Ok, now it looks like something.

According to John Smith, this version of the program is the _second_ *fastest* and *easiest* to read, write, and maintain.

John also mentions the unimplemented methods are much more involving to write than with our Haskell dialect. What?

Moreover, John mentions he uses quite a few faster- and easier-to-use languages than this one, that still fit in the category of object-oriented, imperative languages. Isn't this surprising, again? Let's not hear him more on Java.

h4. Some Procedural C Dialect

So, where's the program?

Wait, we know it would look almost the same as that of Java, just much more awkward in large systems. No need to bother writing this, right?

I know you can easily imagine how you would program the unimplemented functions, like mixProgressively(...). We can easily see how awkward it would be to write them without them fitting in the greater scheme of the object-oriented paradigm.

According to John Smith, this version of the program is the _second_ *longest* and *hardest* to read, write, and maintain.

Rock on, John! We now understand each other. No need to spend more time with C. Let's see what's next.

h4. Some Procedural Assembly Language Dialect

So, where's the program?

Wait, did you really expect me to write this whole stuff in assembly language!? I mean, isn't it, by all means, completely evident how hard and long it would take me to write and debug this stuff?

Try to imagine how you would program everything, including the unimplemented procedures, like mixProgressively. Wouldn't it be longer to do than with Java's @for@ comprehensions or C's @for@ statement, and all those neat features we're used to?

Now, according to John Smith, this version of the program is _the_ *longest* and *hardest* to read, write, and maintain.

Ah! Rock on, John! We truly understand each other. _Wait_, that's right, we weren't used to think like you just some time ago...

h3. Stop taking the Chef for a fool!

If we consider that:

* each one of the program versions we looked at was successively closer to machine-level details, and
* John's opinions were really true,

then we can safely derive some conclusions.

h4. Conclusion

| Each time we step *closer* to the *machine-level* details... |
|>. ...we need to invest *more mental effort* and *more time* to write something. |
| <br /> |
| Each time we step *farther* away from the *machine-level* details... |
|>. ...we need to invest *less mental effort* and *less time* to write something. |

h5. Rantings

Now, my question is, _who on earth_ decided that Java was far enough from machine-level details?

In other words, who, after having known the enlightenment coming from stepping away from the machine-level details, decided it would be wrong to pursue further enlightenment by continuing to step away from the machine-level details? 

Well, let's get back to constructive stuff.

h4. Some Chef Dialect

Isn't it worth to pursue such clarity and succinctness?

<pre>
Buckle (Blueberry)
</pre>

Of course, no general-purpose programming language allows that level of expressivity (that is, without writing anything to back the expression given in the example). This example is clearly an exaggeration of what the perfect programming language could be. It's meant to illustrate how Domain-Specific Languages (DSLs) can be interesting.

Now, this is where we raise an interesting question. Which kind of programming language would be the most effective at writing DSLs?

John says the answer is to be found somewhere in the category of declarative languages. Functional languages are a category of declarative languages.

h4. Who's The Chef?

Or, in another words, who's the one taken for a fool?

h5. It's The Compiler!

Obviously, the Chef is our programming language's compiler. Right? After all, whatever was the level of programming language we used, we always wrote the instructions that it needed to produce what we wanted to eat.

Of course, the more succinctly the compiler allows us to express what we want, the better Chef it is.

h5. The Dynamics Of Compilers

But it's us, isn't it, who programmed the behavior of the Chef, in our object-oriented version? Yes, that's right. Each one of Chef's unimplemented methods would have to be written by us. And each one of Chef's method calls, too, have been written by us. And in the non-object-oriented languages, although we didn't explicitly mention Chef, we were still writing equivalent code. So we understand that whatever the paradigm and language we use to program a computer, we always end up writing everything the compiler doesn't write for us.

In other words, we write the reciprocal of what the compiler writes:

<pre>
ourCode + compilerCode = program
</pre>

From this, we can derive:

<pre>
ourCode      = program - compilerCode
compilerCode = program - ourCode
</pre>

Since we don't care about @program@ as long as it's constant, we can write:

<pre>
ourCode      = -compilerCode
compilerCode = -ourCode
</pre>

And we've reached the reciprocal.

Now, if this doesn't make sense at all to you, there's a good reason for it. _Any_ successful high-schooler could beat my long-forgotten maths skills. Therefore, please correct me if I'm wrong in any way.

h5. Then Who's The Compiler?

So in reality, the Chef is made up of two entities. First, human-generated code. Second, compiler-generated code. In other words, the compiler is made up of a human compiler and a machine compiler. Hey, don't call me a compiler, that's _gross_!

h5. Our Choice

Now, trust John, we don't want to be the Chef. That's why we don't use assembly language unless we really don't have any other choice. It's better to have a Chef at our service. And it's even much, much better if our Chef is intelligent enough that we don't have to go at lengths for him to understand what we truly want to eat.

Therefore, if we could find a Chef that allows us to express our desires five times more succinctly and clearly than the one that comes with Java, wouldn't we be up for total enlightenment? We could either write five times faster the same programs as what we write today with Java, or take the same time that we're used to, but to get programs five times more interesting. 

Wow! I want to work with a better Chef. Don't you?

h2. Is Formality What We Want?

Then express it through a formal language!

h2. Value Transparency, not Opaqueness

h2. Fundamental Problems Of The Imperative Way

h3. The Assignment Statement

Turner, p.5, "It is because of this that it is so difficult to reason about programs. Since expressions can change their value through time, equality is not substitutive. Indeed, in a programming language it does not even have to be true that an expression is equal to itself (because the presence of side effects may mean that evaluating the same expression twice in succession can produce two different answers)! In general it is not possible to reason about such programs on the basis of a static analysis of the program text - instead we have to think of the program dynamically and follow the detailed flow of control [...]"

h2. The Imperative Coalition's Last Hopes

h3. Object Orientation

h3. Higher-Order Functions

h3. Limits

h2. References

h3. 1977 - John Backus

h4. Bio

*** "Wikipedia's Page":en.wikipedia.org/wiki/John_Backus
*** "Alex Aiken's Memorial":theory.stanford.edu/~aiken/other/backus.pdf
*** "IBM's Exhibit":http://www-03.ibm.com/ibm/history/exhibits/builders/builders_backus.html

h4. Paper

*** "Can Programming Be Liberated from the von Neumann Style?":theory.stanford.edu/~aiken/other/backus.pdf

h3. 1982 - David Turner

h3. 1984 - John Hughes

** "Why Functional Programming Matters":www.address.com